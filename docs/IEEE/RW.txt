* Goff91 - Practical Dependence Testing
[Insights]
- Typical dependence tests are more general than necessary.
- Most array references in scientific Fortran code are simple.
- Provides new algorithms for exact dependence tests.
- Provide a very nice historical perspective of dependence testing.
[Differences]
- Deals with a different problem.
- We can use it to increase the precision of our dependence graph.

* Kreaseck00 - Limits of Task-based Parallelism in Irregular Applications
[Insights]
- Speculative Task Parallelism.
- Use of futures.
- Execute task speculatively, based on profiling, and rollback if necessary.
[Similarities]
- Search for parallelism in irregular loops.
[Differences]
- We use a concrete execution model. They use a hypothetical machine.
- We implement actual parallelization.
- We do not do speculation.

* Kulkarni09 - How Much Parallelism is There in Irregular Applications?
[Insights]
- A profiler that detects parallelism in applications
- The notion of 'how much parallelism is there' can be more useful than
speedup information.
[Differences]
- This is not a work of automatic parallelization.
- We can cite it to say that "there is a lot of parallelism in irregular
applications".

* Li12 - Automatic Extraction of Coarse-Grained Data-Flow Threads from
         Imperative Programs
[Insights]
- Static analysis to find data-flow parallelism in imperative programs.
- Optimizations to coarsen the grain of parallelism
[Differences]
- Does not seem to have support of the runtime?
- Does not handle pointers and aggregate types.

* Pingali11 - The Tao of Parallelism in Algorithms
[Insights]
- Parallelism in irregular applications depends on data.
- Dependence graph is not able to find this parallelism.
- Proposes new primitives to code algorithms.
[Similarities]
- Seek to find parallelism in irregular applications.
- "Dependences between activities in irregular algorithms are usu- ally complex
  functions of runtime data values, so they cannot be usefully captured by a
  static dependence graph."
- We agree with the above sentence. Our approach uses a static analysis to
  detect tasks, but it is up to the runtime if we can run that task in
  parallel with other tasks already in flight.
- We can use Delaunay Triangulation as an example of program that we can
  parallelize.
[Differences]
- Requires a new language, or at least new abstractions, to write parallel
  algorithms. Our approach should be totally automatic.
- Our approach still relies on static dependance graphs to find parallelism 
	opportunities.
